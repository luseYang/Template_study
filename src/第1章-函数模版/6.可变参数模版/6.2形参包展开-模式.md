那么问题来了，存储很简单，我们要如何把这些东西取出来使用呢？这就涉及到另一个知识：[形参包展开](https://zh.cppreference.com/w/cpp/language/parameter_pack#.E5.8C.85.E5.B1.95.E5.BC.80)。
```cpp
void f(const char*, int, double) { puts("值"); }
void f(const char**, int*, double*) { puts("&"); }

template<typename...Args>
void sum(Args...args){  // const char * args0, int args1, double args2
    f(args...);   // 相当于 f(args0, args1, args2)
    f(&args...);  // 相当于 f(&args0, &args1, &args2)
}

int main() {
    sum("luse", 1, 1.2);
}
```
sum 的 ```Args...args``` 被展开为 ```const char * args0, int args1, double args2```。  

这里我们定义一个术语：**模式**。  

后随省略号且其中至少有一个形参包的名字的**模式**会被展开 成零个或更多个**逗号分隔**的模式实例。

```&args...``` 中 ```&args``` 就是模式，在展开的时候，模式，也就是省略号前面的一整个表达式，会被不停的填入对象并添加 ```&```，然后逗号分隔。直至形参包的元素被消耗完。  

那么根据这个，我们写一点抽象的东西：
```cpp
template<typename...Args>
void print(const Args&...args){    // const char (&args0)[5], const int & args1, const double & args2
    int _[]{ (std::cout << args << ' ' ,0)... };
}

int main() {
    print("luse", 1, 1.2);
}
```
slow it down：```(std::cout << args << ' ' ,0)...```是一个包展开，那么它的模式是：```(std::cout << args << ' ' ,0)```，实际的展开是：
```cpp
(std::cout << arg0 << ' ' ,0), (std::cout << arg1 << ' ' ,0),(std::cout << arg2 << ' ' ,0)
```
很明显是为了打印，但是为啥要括号里加个逗号零呢？这是因为逗号表达式是从左往右执行的，返回最右边的值作为整个逗号表达式的值，也就是说：每一个 ```(std::cout << arg0 << ' ' ,0)``` 都会返回 0，这主要是为了符合语法，用来初始化数组。我们创建了一个数组 ```int _[]``` ，最终这些 0 会用来初始化这个数组，当然，这个数组本身没有用，只是为了创造合适的[包展开场所](https://zh.cppreference.com/w/cpp/language/parameter_pack#.E5.B1.95.E5.BC.80.E5.9C.BA.E6.89.80)。
> 为了简略，我们不详细说明有哪些展开场所，不过我们上面使用到的是在花括号包围的初始化器中展开。
* **_只有在合适的形参包展开场所才能进行形参包展开_**。
```cpp
template<typename ...Args>
void print(const Args &...args) {
   (std::cout << args << " ")...; // 不是合适的形参包展开场所 Error！
}
```
---

<details>
  <summary>细节</summary>
  <div>
    <pre><code>
    template<typename...Args>
    void print(const Args&...args){    
        int _[]{ (std::cout << args << ' ' ,0)... };
    }
    </code></pre>
  </div>
</details>








