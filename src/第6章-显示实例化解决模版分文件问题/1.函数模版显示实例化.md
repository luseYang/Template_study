# 前言
在前面的内容，我们一直讲的都是 **“通常写法，函数模板、类模板、变量模板不能分文件”。** 

并且阐述了原因，简单的说：**在于模板必须使用了才会生成实际的代码，才会有符号让链接器去链接。**

- **只有实例化模板，编译器才能生成实际的代码。**
> 需要注意，以前说的“使用模板”其实就是会[隐式实例化](https://zh.cppreference.com/w/cpp/language/function_template#.E9.9A.90.E5.BC.8F.E5.AE.9E.E4.BE.8B.E5.8C.96)模板，编译器根据我们的使用，知道我们需要什么类型的模板，生成实际的函数，实际的类，实际的变量等，然后再去调用。

如果想要进行分文件，就需要对摸吧进行显示实例化。  

我们要自己指明需要哪些具体的函数

---

# 函数模版显示实例化
```cpp
template 返回类型 名字 < 实参列表 > ( 形参列表 ) ;          (1)
template 返回类型 名字 ( 形参列表 ) ;                       (2)
extern template 返回类型 名字 < 实参列表 > ( 形参列表 ) ;   (3) (C++11 起)
extern template 返回类型 名字 ( 形参列表 ) ;                (4) (C++11 起)
```
1. 显式实例化定义（显式指定所有无默认值模板形参时不会推导模板实参）
2. 显式实例化定义，对所有形参进行模板实参推导
3. 显式实例化声明（显式指定所有无默认值模板形参时不会推导模板实参）
4. 显式实例化声明，对所有形参进行模板实参推导

- 在模板分文件问题中，几乎不会使用到显式实例化声明。

因为我们引用 .h 文件本身就有声明，除非你准备直接两个 .cpp。
> **显式实例化定义强制实例化它所指代的函数或成员函数**。它可以出现在程序中模板定义后的任何位置，而对于给定的实参列表，它在整个程序中只能出现一次，不要求诊断。

> 显式实例化声明（extern 模板）阻止隐式实例化：本来会导致隐式实例化的代码必须改为使用已在程序的别处所提供的显式实例化。(C++11 起)

> 在函数模板特化或成员函数模板特化的显式实例化中，尾部的各模板实参在能从函数参数推导时不需要指定。
