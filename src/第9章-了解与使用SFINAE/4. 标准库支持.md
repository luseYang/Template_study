# std::enable_if

```cpp
#include <iostream>

// std::enable_if
// 如何要求 T 必须是 int 类型

template<typename T, typename SFINAE = 
	std::enable_if_t<std::is_same_v<T, int>>>	
void f(T) {
	std::cout << "T = int" << '\n';
}

int main() {
	f(1);
	// f(1u);      报错，没有找到合适的模版
}
```

这里用到了 `std::enable_if`：

```cpp
template<bool B, class T = void>
struct enable_if {};
 
template<class T> // 类模板偏特化
struct enable_if<true, T> { typedef T type; };     // 只有 B 为 true，才有 type，即 ::type 才合法

template< bool B, class T = void >
using enable_if_t = typename enable_if<B,T>::type; // C++14 引入
```

这是一个模板类，在 C++11 引入，它的用法很简单，就是第一个模板参数为 `true`，此模板类就有 `type`，不然就没有，以此进行 SFINAE。

```cpp
template<typename T,typename SFINAE = 
    std::enable_if_t<std::is_same_v<T,int>>>
void f(T){}
```

函数 `f` 要求 `T` 类型必须是 `int` 类型；我们一步一步分析

`std::enable_if_t<std::is_same_v<T,int>>>` 如果 `T` 不是 `int`，那么 `std::is_same_v` 就会返回一个 `false`，也就是说 `std::enable_if_t<false>` ，带入：

```cpp
using enable_if_t = typename enable_if<false,void>::type; // void 是默认模板实参
```

但是如果 `enable_if` 的第一个参数是 `false` ，就根本不存在 `type` 成员。

所以这里是个代换失败，但是因为 **“代换失败不是错误”**，所以只是不选择函数模板 `f`，而不会导致编译错误。

再谈，std::enable_if 的默认模板实参是 void，如果我们不在乎 std::enable_if 得到的类型，就让它默认就行，比如我们的示例 f 根本不在乎第二个模板形参 SFINAE 是啥类型。

---

```cpp
template <class Type, class... Args>
array(Type, Args...) -> array<std::enable_if_t<(std::is_same_v<Type, Args> && ...), Type>, sizeof...(Args) + 1>;
```

以上示例，是显式指明了 `std::enable_if` 的第二个模板实参，为 `Type`。

它是我们类模板推导指引那一节的示例的改进版本，我们使用 `std::enable_if_t` 与 `C++17` 折叠表达式，为它增加了约束，这几乎和 `libstdc++` 中的代码一样。

`(std::is_same_v<Type, Args> && ...)` 做 `std::enable_if` 的第一个模板实参，这里是一个一元右折叠，使用了 `&&` 运算符，也就是必须 `std::is_same_v` 全部为 `true`，才会是 `true`。简单的说就是要求类型形参包 `Args` 中的每一个类型全部都是一样的，不然就是替换失败。

这样做有很多好处，老式写法存在很多问题：

```cpp
template<class Ty, std::size_t size>
struct array {
    Ty arr[size];
};

template<typename T, typename ...Args>
array(T t, Args...) -> array<T, sizeof...(Args) + 1>;

::array arr{1.4, 2, 3, 4, 5};        // 被推导为 array<double,5>
::array arr2{1, 2.3, 3.4, 4.5, 5.6}; // 被推导为 array<int,5>    有数据截断
```

如果不使用 SFINAE 约束，那么 `array` 的类型完全取决于第一个参数的类型，很容易导致其他问题。

 
