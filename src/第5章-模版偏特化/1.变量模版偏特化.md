# 模版偏特化
模板偏特化这个语法让**具有一些相同特征**的模版实参可以实现自定义，而不是像全特化那样，必须是具体的什么类型，什么值。

比如全特化，只能分别指明特化 int*， char* 等等，但偏特化可以直接指明特化指针类的类型。

- 模板偏特化使我们可以对具有相同的一类特征的类模板、变量模板进行定制行为。

## 变量模版偏特化
```cpp
#include <iostream>

template<typename T>
const char* s = "?";	// 主模版

template<typename T>
const char* s<T*> = "pointer";	// 偏特化，对指针这一“类”类型

template<typenmae T>
const char* s<T[]> = "array";	// 偏特化，但是只是对 T[] 这一“类”类型，而不是数组类型。因为 int[1] 和 int[2] 不是一个类型。

int main(){
    std::cout << s<int*> << '\n';		// pointer
	std::cout << s<void*> << '\n';		// pointer
	std::cout << s<double*> << '\n';	// pointer
	std::cout << s<int> << '\n';		// ?
	std::cout << s<int[]> << '\n';		// array
	std::cout << s<double[]> << '\n';		// array
	std::cout << s<double[1]> << '\n';		// ?
}
```
上述的int[1] 和 int[2]不同，因为数组的类型由元素类型和数组大小组成。
&emsp;  
```cpp
#include <iostream>

template<typename T, typename T2>
const char* s = "?";	// 主模版

template<typename T2>
const char* s<int, T2> = "T == int";

int main(){
	std::cout << s<char, double> << '\n';	// ?
	std::cout << s<int, int*> << '\n';		// T == int
	std::cout << s<int, double> << '\n';	// T == int
}
```


