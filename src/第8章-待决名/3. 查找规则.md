# 查找规则

```cpp
#include<iostream>

template<class T>
struct X {
    void f()const { std::cout << "X\n"; }
};

void f() { std::cout << "全局\n"; }

template<class T>
struct Y : X<T> {
    void t()const {
        this->f();
    }
    void t2()const {
        f();
    }
};

int main() {
    Y<void>y;
    y.t();
    y.t2();
}
```

以上代码的运行结果是：

```
X
全局
```

名字查找分为：[有限定名字查找](https://zh.cppreference.com/w/cpp/language/qualified_lookup)，[无限定名字查找](https://zh.cppreference.com/w/cpp/language/unqualified_lookup)。

> 有限定名字查找指？
> 
> 出现在作用域解析操作符 :: 右边的名字是限定名（参阅有限定的标识符）。 限定名可能代表的是：
> 
> - 类的成员（包括静态和非静态函数、类型和模板等）
> - 命名空间的成员（包括其他的命名空间）
> - 枚举项

如果 `::` 左边为空，那么查找过程只会考虑全局命名空间作用域中作出（或通过 `using` 声明引入到全局命名空间中）的声明。

```cpp
this->f();
```

那么显然，这个表达式不是有限定名字查找，那么我们就去[无限定名字查找](https://zh.cppreference.com/w/cpp/language/unqualified_lookup)中寻找答案。

我们找到模板定义：
> 对于在模板的定义中所使用的**非待决名**，当检查该模板的定义时将进行**无限定的名字查找**。在这个位置与声明之间的绑定并不会受到在实例化点可见的声明的影响。而对于在模板定义中所使用的**待决名，它的查找会推迟到得知它的模板实参之时**。此时，ADL 将同时在模板的定义语境和在模板的实例化语境中检查可见的具有外部连接的 (C++11 前)函数声明，而非 ADL 的查找只会检查在模板的定义语境中可见的具有外部连接的 (C++11 前)函数声明。（换句话说，在模板定义之后添加新的函数声明，除非通过 ADL 否则仍是不可见的。）如果在 ADL 查找所检查的命名空间中，在某个别的翻译单元中声明了一个具有外部连接的更好的匹配声明，或者如果当同样检查这些翻译单元时其查找会导致歧义，那么行为未定义。无论哪种情况，**如果某个基类取决于某个模板形参，那么无限定名字查找不会检查它的作用域（在定义点和实例化点都不会）。**

很长，但是看我们加粗的就够：

- 非待决名：检查该模板的定义时将进行无限定的名字查找  
- 待决名：它的查找会推迟到得知它的模板实参之时

我们这里简单描述一下：

`this->f()` 是一个待决名，这个 `this` 依赖于模板 `X`。

所以，我们的问题可以解决了吗？

`this->f()` 是待决名，所以它的查找会推迟到得知它模板实参之时（届时可以确定父类是否有 `f` 函数）。  
`f()` 是非待决名，检查该模板的定义时将进行无限定的名字查找（无法查找父类的定义），按照正常的查看顺序，先类内（查找不到），然后全局（找到）。

> 补充：如果是 `msvc` 的某些早期版本，或者 C++ 版本设置在 C++20 之前，会打印 `X X`。这是因为 `msvc` 不支持二阶段名字查找 [Two-phase name lookup](https://learn.microsoft.com/zh-cn/archive/blogs/c/msvc%E5%B7%B2%E7%BB%8F%E6%94%AF%E6%8C%81two-phase-name-lookup)。
